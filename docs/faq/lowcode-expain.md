# 1. 代码生成器是低码吗？

传统的代码生成器只是一次性脚手架，不支持持续的增量化改进，所以它不是低码的。典型的，一旦生成代码之后，所有客户化定制工作都需要修改生成代码，从而脱离原有
的模型约束，当我们对模型进行了增量调整之后，重新出码会覆盖所有代码，丢失手工修改内容。

是否在运行时解释执行还是生成代码编译执行本身在概念层面并没有本质性差异。在理论层面，编译可以看作是函数式编程中curry化的一种具体实现手段。解释执行对应于
render(schema, data) , 对应于curry化 render(schema)(data)，而编译执行对应于 component = compile(schema); component(data)。 
compile相当于是render函数与schema的信息进行预结合。

Nop平台在元编程阶段的大量结构转换也可以看作是一种编译过程，所以整体可以看作是一种多阶段编译，并不只是生成通用语言源码这一个编译阶段

出码有可能出的是DSL代码，而并不一定是通用语言代码，例如Nop平台在前端目前出的是amis代码，在前台交由amis引擎负责解释运行。
本质上代码只是信息的一种载体。业务信息一旦得到精确的表达，应该可以使用多种载体去承载，特别是应该可以逆向抽取得到原始编程意图


# 2. 低码自己的核心领域模型如何定义？
一些低代码平台在固化的少数场景中显得非常强大，可以非常快速的以固化的模式实现某些业务。但是我们认为强大的本质在于内在演化的基因，而不是堆砌的功能。
恐龙很强大，却在环境变迁中被无情的淘汰。现有的低代码产品主要还是采用穷举法，内置大量的功能特性，但是技术环境不断变迁，它能否快速适应?不要说别的，能否迁移到最新的基础技术平台上就是一个很明显的挑战。大量的功能都是采用过去流行的某种技术构建，很可能会绑定在某个技术框架版本上。

低代码的能力来源于建模，而强大的低代码应该是支持立刻新建模型并自由扩展已有模型的，这要求基础架构至少是具有元模型定义。

Nop平台自身的所有模型都统一使用xdef元模型来定义所有的模型，而xdef元模型由xdef元模型自身来约束，即元元模型仍然是xdef。平台的核心实际上是通用的Tree结构变换、加载机制，而DSL不过是具有语义的某种Tree。

具体来说，我们的做法是定义xdef元模型之后，立刻自动推导得到设计器，并在IDEA中通过一个统一的插件根据元模型自动实现语法提示，支持DSL断点调试等。所以本质上是一种面向语言的编程范式：解决业务领域的问题之前，先制定一个面向特定领域的DSL，然后再用DSL来开发业务，而平台的作用是将开发并扩展已有DSL的成本降到与开发一个函数的成本类似。

低代码如果要面向广泛的编程领域，而不仅仅局限在少数CRUD场景，它的核心领域模型就不应该是少数面向业务的固化模型，而是一种快速创建新的领域模型的元模型的能力。


# 3. DSL需要图灵完备吗？

DSL可以图灵完备，也可以不要求图灵完备，但是涉及到领域知识的子部分，它应该支持反向信息抽取，这个子部分原则上是描述式而且不是图灵完备的。一个语言相当于是一个坐标系，一个通用语言相当于是一个万能坐标系，所有信息都采用这个坐标系表达，但是DSL相当于是某种局部坐标系，多个局部坐标系粘结在一起构成整体坐标系（可以类比微分流形的概念）。所以实际解决问题的时候，我们是通过DSL森林来解决问题。**图灵机能够实现图灵完备的根本原因在于图灵机可以被看作是一种虚拟机**，它可以模拟所有其他的自动计算机器，而如果我们不断提升虚拟机的抽象层次，就会得到可以直接"运行"所谓领域特定语言(DSL)的虚拟机，但是因为DSL关注的重点是特定领域概念，它必然无法以最便利的方式表达所有通用计算逻辑（否则它就成为了通用语言），必然会导致某种信息溢出，成为所谓的Delta项。

