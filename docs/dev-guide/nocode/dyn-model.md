# 在线动态建模

无代码（NoCode）开发模式要求用户可以在线调整数据模型、流程模型等模型对象，无需经过编译、打包、部署的的过程，立刻就能够看到模型调整后的运行结果。

Nop平台目前的演示大部分是在开发阶段进行模型设计，然后通过代码生成来产生程序源码，很多人因此误以为Nop平台的技术方案并不适用于在线动态建模。

在本文中，我将结合Nop平台中的NopDyn模块的实现，介绍一下Nop平台中动态模型管理方面的内容。



## 一. 通过DSL实现解耦

为了支持运行时进行模型设计的动态性，传统的技术实现方案中设计工具和运行时引擎结合得非常紧密，这导致两者之间的逻辑相互纠缠，无论是设计改进还是性能改进都会遇到很多限制。

$$
设计态 \Longrightarrow 运行态
$$

Nop平台强调DSL优先，而不是可视化设计优先。（参见[从可逆计算看DSL的设计要点](https://zhuanlan.zhihu.com/p/646144092)）

$$
设计态 \overset {代码生成} \Longrightarrow  虚拟文件系统 \overset {通用加载} \Longrightarrow 运行态
$$

在Nop平台中，设计工具和运行时引擎通过DSL实现了解耦。

1. 设计工具的输出产物是DSL模型文件

2. 运行时引擎的输入信息是DSL模型文件

3. **DSL模型文件由虚拟文件系统统一管理**

借助于虚拟文件系统的抽象，DSL的实际存储形式可以是硬盘上的文件，也可以是数据库中的某条记录（或者是一组关联的记录），也可以是内存中的一段文本缓存。模型保存为DSL文件然后再解析得到运行时模型对象的过程可以看作是**对JSON序列化过程的一种非对称扩展**：设计时模型序列化后产生的文本是DSL，而**反序列化得到的运行时模型并不需要与设计时模型一致**，而完全可以是一种针对运行时优化后的模型结构。

$$
Model \Longrightarrow  JSON  \Longrightarrow Model \\
DesignModel \Longrightarrow DSL \Longrightarrow RuntimeModel
$$

更进一步，**从设计时模型到DSL的产生过程并不是唯一的**，我们完全可以针对不同的业务使用场景提出多种不同形式的设计时模型，只需要它们可以通过某种代码生成过程产生我们所需的DSL文本结构即可。例如，在Nop平台中底层的工作流引擎并不是针对审批场景定制的工作流引擎，它没有内置的会签、串签等概念，但是我们可以提供一个定制的、类似钉钉工作流的可视化设计器，它产生一种树形结构的模型对象，然后再通过编译期模型转换自动生成底层的图结构的工作流DSL。

也就是说，从DesignModel到DSL可以是一个代码生成的过程，它可以通过一个代码生成器来完成。一说到代码生成，很多人的第一印象就是它是开发阶段才存在的概念，不适合于动态模型设计。但是如果结合虚拟文件系统的抽象，代码生成与JSON序列化并没有本质上的差异：都是生成内存中的一段文本而已。

Nop平台内置了强大的模板驱动的代码生成器，可以实现NoCode开发与ProCode开发共享一部分代码生成模板。参见[数据驱动的差量化代码生成器](https://zhuanlan.zhihu.com/p/540022264)。

在另一个方向上，**解析DSL得到模型对象的过程在Nop平台中被标准化了**：只需要定义DSL所对应的XDef元模型，即可自动实现模型对象解析。参见[替代XSD的统一元模型定义语言:XDef](https://zhuanlan.zhihu.com/p/652191061)。

在Nop平台中，我们可以使用如下方式来根据虚拟文件路径加载任意模型对象

```javascript
model = ResourceComponentManager.instance().loadComponentModel(modelPath)
```

加载过程中会自动实现模型缓存，并跟踪模型文件之间的依赖关系：当某个模型文件被修改之后，所有依赖于该模型文件的模型缓存会自动失效。统一模型加载器所做的工作本质上类似于前端的webpack、vite这种支持依赖跟踪的打包工具。详细介绍视频参见[低代码平台中的统一模型加载器](https://www.bilibili.com/video/BV1rH4y117hd/)。

## 二. NopDyn动态建模

任何一种动态更新技术本质上都是在定义一种Delta差量空间以及这个空间中可行的结构合成运算。Nop平台中的XDSL层面的差量合并机制相当于是一种标准化的、与业务无关的差量运算。
关系数据库模型之所以能够标准化存储机制，是它只保存原子化的数据，然后通过运算衍生出最终需要的数据。而XDSL本质上也是用XNode保存无冗余的模型数据，然后在加载的过程中再产生关联对象引用。
